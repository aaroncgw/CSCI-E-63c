---
title: 'CSCI E-63C: Final Exam/Project'
author: 'Joshua Sacher'
date: '`r Sys.Date()`'

output:
  html_document:
    df_print: kable
    number_sections: true
    toc: true
    toc_float:
      collapsed: false
---

```{r setup, include=FALSE}
# Libraries to use
libraries <-
  c(
    "boot",
    "cowplot",
    "e1071",
    "GGally",
    "ggplot2",
    "ISLR",
    "MASS",
    "neuralnet",
    "PCAmixdata",
    "psych",
    "randomForest"
  )
# Load libraries
invisible(lapply(libraries, library, character.only = TRUE))

knitr::opts_chunk$set(echo = TRUE,
                      fig.height = 6,
                      fig.width = 8)
```

# Preface

For the final exam/project we will develop classification models using several approaches and compare their performance on a new dataset that is a subset of one of the datasets used in machine learning common task framework (CTF) competitions.  A copy of it split into training (`final-data-train.csv`, with outcome `response` available) and test (`final-data-test.csv`, stripped of the outcome, for prediction purposes only) datasets is available on our course website in Canvas as a zip-archive of all associated files.

Please notice, that at the end of this final exam/project you will be asked, in addition to the Rmarkdown and HTML files, to also make predictions for the observations in the *test* (not training!) dataset and upload them into Canvas as well.  The expected format for the file with predictions for test dataset is two columns of comma-separated values, one row per observation in *test* dataset, first column -- the observation identifier (column `id` in test dataset) and the second column -- your best model predictions for each observation in the *test* dataset as Y/N indicator.  To illustrate expected format the zip archive contains also a couple of examples of test predictions in this format for your reference as well (`predictions-*.csv` files in `predictions-examples` sub-folder in zip-archive).

One more time, to iterate and emphasize, please notice that this time your submission must consist of the following *three* (not just two, Rmd+html, as usual) items:

* Rmarkdown *.Rmd file with all the calculations you want to receive credit for,
* HTML version of the output generated by your *.Rmd file, and
* **predictions** for the **test** dataset in comma-separated values (CSV) format (file name **must** have *.csv extension for the file to load in Canvas)

The teaching team invites you to load your predictions (just predictions, just for the test dataset according to the file format shown in the sample files in the zip-archive) into Canvas repeatedly as you work on your models and improve them over the course of this week.  At least daily (or more frequently as we see fit) we will download predictions loaded by everyone by that time and compile a leaderboard in html format of all of them sorted by their accuracy as compared to the true values of the outcome for the test dataset (along with their sensitivity, specificity, etc.).  This list will be made available on our course website in Canvas for everyone in this class in order to see how the performance of their models compares across the rest of the models built by other students in the class.  The first version of the leaderboard posted on the course website at the time when final exam is made available starts with predictions made by those few example files provided in the zip-archive (coin flip, majority vote, etc. -- what do you think Charlie Brown is using to make the predictions?).  Those should be pretty easy to improve upon.

It is 100% up to you whether you want to upload your model predictions over the course of this week, how frequently you want to do it and what you want its results to be called in the leaderboard posted for everyone in the class to see.  We will use the name of the 2nd column in the file with predictions (the one containing Y/N values, not the numerical ids of the observations) as the model name listed in the leaderboard.  If you prefer not to use your name, choose something else instead, sufficiently unique so that it is easier for you to spot your result among all others.  Once again, please check out sample files of dull (majority vote, coin flip, etc.) predictions we have made available and consider how they show up in the leaderboard html file already posted on Canvas website.  Once you are done with final you are expected to load predictions from your best model into Canvas -- that is part of your points total as explained below.

Lastly, the size of this dataset can make some of the modeling techniques run slower than what we were typically encountering in this class.  You may find it helpful to do some of the exploration and model tuning on multiple random samples of smaller size as you decide on useful ranges of parameters/modeling choices, and then only perform a final run of fully debugged and working code on the full dataset.  Please see also the afterword below on the computational demands of this problem set.

# Problem 1: univariate and unsupervised analysis (20 points)

_Download and read training and test data into R and prepare graphical and numerical summaries of it: e.g. histograms of continuous attributes, contingency tables of categorical variables, scatterplots of continuous attributes with some of the categorical variables indicated by color/symbol shape, etc.  Whatever you find helpful to think about properties of the data you are about to start using for fitting classification models._

```{r Data loading and stats, cache=TRUE}
# Load training data, check for NA values, look at summary
train.all <- read.csv("final-data-train.csv")
anyNA(train.all)
str(train.all)
summary(train.all)

# Data with ID removed so it doesn't get included in the model
train.id <- train.all$id
train <- subset(train.all, select = -id)

# Convert response to boolean, ("Y" = TRUE)
train$response <- train$response == "Y"

# Exploring continuous variables
train.continuous <-
  subset(train, select = c(response, dtj, qh, sci, ypz, bw, is))
ggpairs(
  train.continuous,
  aes(color = as.factor(response), alpha = 0.5),
  columns = 2:ncol(train.continuous),
  progress = FALSE
)

# Data transformation trials for continuous variables
par(mfrow = c(1, 2))
hist(train$dtj)
hist(exp(train$dtj))

hist(train$qh)
hist(log(train$qh))

hist(train$is)
hist(sqrt(train$is))

par(mfrow = c(1, 1))

train.trans <- cbind(
  subset(train, select = -c(dtj, qh)),
  exp.dtj = exp(train$dtj),
  log.qh = log(train$qh),
  sqrt.is = sqrt(train$is)
)
train.trans.continuous <- subset(train.trans,
                                 select = c(response, exp.dtj, log.qh,
                                            sci, ypz, bw, sqrt.is))
ggpairs(
  train.trans.continuous,
  aes(color = as.factor(response), alpha = 0.5),
  columns = 2:ncol(train.continuous),
  progress = FALSE
)


# Function to generate histograms
hists <- function(X) {
  p <-
    ggplot(
      train.trans.continuous,
      aes(x = train.trans.continuous[[X]], color = response, fill = response)
    )
  p <-
    p + geom_histogram(bins = 25,
                       position = "identity",
                       alpha = 0.4)
  p <- p + labs(title = paste("Distribution of", X), x = X)
  return(p)
}
# Use the function above for each of the 7 measurements
plots <-
  lapply(names(subset(train.trans.continuous, select = -response)),
         hists)
# Plot as a grid
plot_grid(plotlist = plots, ncol = 2)

# Exploring categorical variables
train.categorical <-
  subset(train, select = -c(dtj, qh, sci, ypz, bw, is))
sapply(train.categorical[,-1], table, train.categorical$response)

# Final training data set
train <-
  cbind(train.trans.continuous,
        subset(train.categorical, select = -response))

```

_As it is often the case for such contests, the attributes in the dataset are blinded in the sense that no information is available about what those are or what their values mean.  The only information available is that the attribute `response` is the outcome to be modeled and the attribute `id` is the unique numerical identifier for each observation.  Some of the remaining attributes are clearly categorical (those that are character valued) and some rather obviously continuous (those with numerical values with large number of unique values).  For several of them it is less clear whether it is best to treat them as continuous or categorical -- e.g. their values are numerical but there are relatively few unique values with many observations taking the same value, so that they arguably could be treated as continuous or categorical.  Please idenify them, reflect on how you prefer to handle them and describe this in your own words._

+ Continuous: dtj, qh, sci, ypz, bw, is
+ Categorical: wc, zwp, wi, bnf, ent, tdt, sb, ox, xt, np, ku
+ Other: id, response (technically categorical-ish for both)

I prefer to leave things as-is in terms of continuous/categorical. That said, there are a number of transformations that make the variable more normally distributed or at least more spread out: $e^{dtj}$, $ln(qh)$, $\sqrt{is}$. Other transformations might be better, but I'm going to stick with those.


_Perform principal components analysis of this data (do you need to scale it prior to that? how would you represent multilevel categorical attributes to be used as inputs for PCA?) and plot observations in the space of the first few principal components indicating levels of some of the categorical attributes of your choosing by the color/shape of the symbol.  Perform univariate assessment of associations between the outcome we will be modeling and each of the attributes (e.g. t-test or logistic regression for continuous attributes, contingency tables/Fisher exact test/$\chi^2$ test for categorical attributes).  Summarize your observations from these assessments: does it appear that there are predictors associated with the outcome `response` univariately? Which predictors seem to be more/less relevant?_

```{r basic PCA on continuous variables, cache=TRUE}
pca.continuous <-
  prcomp(
    subset(train.trans.continuous, select = -response),
    center = TRUE,
    scale = TRUE
  )
plot(pca.continuous)

ggplot(
  data.frame(
    PC1 = pca.continuous$x[, 1],
    PC2 = pca.continuous$x[, 2],
    response = train.trans.continuous$response
  ),
  aes(
    x = PC1,
    y = PC2,
    color = response,
    alpha = 0.4
  )
) + geom_point()

par(mfrow = c(2, 2))
pca.cont <-
  PCAmix(
    X.quanti = scale(subset(train.trans.continuous, select = -response)),
    ndim = length(train.trans.continuous) - 1,
    rename.level = TRUE,
    graph = TRUE
  )
```

```{r Mixed PCA, cache=TRUE}
par(mfrow = c(2, 2))
# Using PCAmixdata library: https://cran.r-project.org/web/packages/PCAmixdata/
pca.all <-
  PCAmix(
    X.quanti = scale(subset(train.trans.continuous, select = -response)),
    X.quali = subset(train.categorical, select = -response),
    ndim = length(train.trans.continuous) + length(train.categorical) - 2,
    rename.level = TRUE,
    graph = TRUE
  )

# MCA on categorical variables
mca <-
  PCAmix(
    X.quali = subset(train.categorical, select = -response),
    ndim = length(train.categorical) - 1,
    rename.level = TRUE,
    graph = TRUE
  )
par(mfrow = c(1, 1))
```

Traditional PCA should only be performed on continuous variables. In doing so, `exp.dtj` ($e^{dtj}$), `log.qh` ($ln(qh)$), and `bw` are the largest constributors to the variance.

Using the `PCAmix` function from the PCAmixdata library allows the combination of continuous and categorical variables. Using this, `log.qh`, `bw`, `zwp` and `xt` explain the most variance.

# Problem 2: logistic regression (20 points)

_Develop logistic regression model of the outcome `response` as a function of multiple predictors in the model.  Which variables are significantly associated with the outcome?  Test model performance on multiple splits of data into training and test subsets and summarize it in terms of accuracy/error/sensitivity/specificity._

```{r Helper function to look at accuracy and other metrics}
assess.prediction <- function(actual, predicted, print.vals = TRUE) {
  # Convert to logical values if needed
  actual = as.logical(actual)
  predicted = as.logical(predicted)
  
  TP = sum(actual & predicted)
  TN = sum(!actual & !predicted)
  FP = sum(!actual & predicted)
  FN = sum(actual & !predicted)
  P = TP+FN # total number of positives in the actual data
  N = FP+TN # total number of negatives
  
  if (print.vals) {
    # For prettiness
    cat("\nCLASSIFIER PERFORMANCE\n")
    # Accuracy (TP + TN) / (TP + TN + FP + FN)
    cat("Accuracy:        ", round(100 * (TP + TN) / (P + N), 1), "%\n", sep ="")
    # Sensitivity TP / (TP + FN)
    cat("Sensitivity:     ", round(100 * TP / P, 1), "%\n", sep ="")
    # Specificity TN / (TN + FP)
    cat("Specificity:     ", round(100 * TN / N, 1), "%\n", sep ="")
    # Precision (Positive Predictive Value) TP / (TP + FP)
    cat("Precision:       ", round(100 * TP / (TP + FP), 1), "%\n", sep ="")
    # False discovery rate 1 - PPV
    cat("False Discovery: ", round(100 * FP / (TP + FP), 1), "%\n", sep ="")
    # False positive rate 1 - TNR
    cat("False Positive:  ", round(100 * FP / N, 1), "%\n", sep ="")
    cat("\n")
  }
  
  # Return table for printing
  return(table(actual = actual, predicted = predicted))
}
```

```{r Logistic regression, cache=TRUE, warning=FALSE}
# Full model
logi <- glm(response ~ ., data = train, family = "binomial")
summary(logi)
# Training error of model fit on all data
assess.prediction(actual = train$response,
                  predicted = predict(logi) > 0.5)

# Repeated 80:20 validation
logi.acc <- numeric()
for (i in 1:50) {
  temp.data <- sample(
    c(TRUE, FALSE),
    size = nrow(train),
    replace = TRUE,
    prob = c(0.8, 0.2)
  )
  temp.model <-
    glm(response ~ ., data = train[temp.data, ], family = "binomial")
  temp.table <-
    assess.prediction(
      actual = train[!temp.data, ]$response,
      predicted = predict(temp.model, newdata = train[!temp.data, ]) > 0.5,
      print.vals = FALSE
    )
  logi.acc <- c(logi.acc, sum(diag(temp.table)) / sum(temp.table))
}
```

```{r Logistic info plots}
describe(logi.acc)

ggplot(data = data.frame(x = "accuracy", y = logi.acc), aes(x = x, y = y)) +
  geom_violin(trim = FALSE, fill = "lightblue") +
  geom_boxplot(fill = "lightgray", width = 0.25)
```

Logistic regression does a surprisingly good job -- the fit of all data gives 87% accuracy. Over repeated 80:20 train/test splits, the accuracy is between 0.86 and 0.88, which is much more consistent that I expected for such a "simple" model.

## Extra points problem: interaction terms (5 extra points)

_Assess the impact/significance of pairwise interaction terms for all pairwise combinations of covariates used in the model and report the top ten that most significantly improve model fit._

```{r Interaction function}
interact <- function (d) {
  # Get names of predictors
  predictors = names(subset(d, select = -response))
  
  # Loop over each predictor
  for (i in 1:length(predictors)) {
    # Loop over all predictors from self onward
    for (j in i:length(predictors)) {
      # Store new column name
      newcol <- paste0(predictors[i], "X", predictors[j])
      # Calculate new data as product of 2 columns
      # and add new data to existing data frame
      d[newcol] = d[[predictors[i]]] * d[[predictors[j]]]
    }
  }
  return(d)
}
```



```{r Logistic regression with interaction, cache=TRUE, warning=FALSE}
# Full(ish) model -- ALL interactions crashes R
# Create interactions and quadratic terms for continuous variables only
train.inter <-
  cbind(interact(train.trans.continuous), train.categorical)
logi.inter <-
  glm(response ~ ., data = train.inter, family = "binomial")
summary(logi.inter)
# Training error of model fit on all data
assess.prediction(actual = train$response,
                  predicted = predict(logi.inter) > 0.5)

# Repeated 80:20 validation
logi.inter.acc <- numeric()
for (i in 1:50) {
  temp.data <- sample(
    c(TRUE, FALSE),
    size = nrow(train),
    replace = TRUE,
    prob = c(0.8, 0.2)
  )
  temp.model <- glm(response ~ .,
                    data = train.inter[temp.data, ],
                    family = "binomial")
  temp.table <-
    assess.prediction(
      actual = train.inter[!temp.data, ]$response,
      predicted = predict(temp.model, newdata = train.inter[!temp.data, ]) > 0.5,
      print.vals = FALSE
    )
  logi.inter.acc <-
    c(logi.inter.acc, sum(diag(temp.table)) / sum(temp.table))
}
```

```{r Logistic with interaction info and plot}
describe(logi.inter.acc)

ggplot(data = data.frame(x = "accuracy", y = logi.inter.acc), aes(x = x, y = y)) +
  geom_violin(trim = FALSE, fill = "lightblue") +
  geom_boxplot(fill = "lightgray", width = 0.25)
```

Accuracy does not improve at all (maybe marginally) by adding interaction and quadratic terms for continuous variables.

Interaction terms ranked by significance are listed below. None fall within the top 25 variables -- not a lot of improvement for a massive increase in computational complexity.

| **Factor**      | **Pr(>|z|)** |
|-----------------|--------------|
| _log.qhXsci_    | _0.010592_   |
| _ypzXbw_        | _0.019562_   |
| _sciXbw_        | _0.02261_    |
| _exp.dtjXsci_   | _0.047289_   |
| sciXsci         | 0.055823     |
| exp.dtjXypz     | 0.146847     |
| sciXypz         | 0.217369     |
| bwXsqrt.is      | 0.218679     |
| bwXbw           | 0.229231     |
| sciXsqrt.is     | 0.272004     |
| log.qhXypz      | 0.274411     |
| sqrt.isXsqrt.is | 0.316467     |
| exp.dtjXlog.qh  | 0.40088      |
| log.qhXlog.qh   | 0.404794     |
| exp.dtjXexp.dtj | 0.570512     |
| ypzXypz         | 0.858855     |
| log.qhXsqrt.is  | 0.879738     |
| log.qhXbw       | 0.924578     |
| exp.dtjXsqrt.is | 0.969719     |
| exp.dtjXbw      | 0.973649     |
| ypzXsqrt.is     | 0.988843     |

# Problem 3: linear discriminant analysis (15 points)

_Fit linear discriminant analysis model of the outcome `response` as a function of the rest of covariates in the dataset.  Feel free to decide whether you want to use all of them or a subset of those.  Test resulting model performance on multiple splits of the data into training and test subsets, summarize it in terms of accuracy/error/sensitivity/specificity and compare them to those obtained for logistic regression._

```{r LDA, cache=TRUE}
# LDA with all data
lda.full <- lda(response ~ ., data = train)
assess.prediction(actual = train$response,
                  predicted = predict(lda.full)$class)

# Repeated 80:20 validation
lda.acc <- numeric()
for (i in 1:50) {
  temp.data <- sample(
    c(TRUE, FALSE),
    size = nrow(train),
    replace = TRUE,
    prob = c(0.8, 0.2)
  )
  temp.model <- lda(response ~ ., data = train[temp.data, ])
  temp.table <-
    assess.prediction(
      actual = train[!temp.data, ]$response,
      predicted = predict(temp.model, newdata = train[!temp.data, ])$class,
      print.vals = FALSE
    )
  lda.acc <- c(lda.acc, sum(diag(temp.table)) / sum(temp.table))
}
```

```{r LDA info and plots}
describe(lda.acc)

ggplot(data = data.frame(x = "accuracy", y = lda.acc), aes(x = x, y = y)) +
  geom_violin(trim = FALSE, fill = "lightblue") +
  geom_boxplot(fill = "lightgray", width = 0.25)
```

LDA slightly improves on the accuracy of logistic regression -- the range has gone up by $1\%$ (min $0.87$, median $0.88$, max $0.89$).

# Problem 4: random forest (15 points)

_Develop random forest model of outcome `response`. Present variable importance plots and comment on relative importance of different attributes in the model.  Did attributes showing up as more important in random forest model also appear as significantly associated with the outcome by logistic regression?  Test model performance on multiple splits of data into training and test subsets, compare test and out-of-bag error estimates, summarize model performance in terms of accuracy/error/sensitivity/specificity and compare to the performance of logistic regression and LDA models above._

```{r Random Forest, cache=TRUE}
# Test out a few values of mtry in the model
rf.acc <- data.frame(mtry = numeric(), accuracy = numeric())
for (m in c(3, 4, 6, 11, 17)) {
  for (i in 1:50) {
    # Use a smaller subset (~33%) of data so it doesn't take days to run!
    train.subset <- train[sample(1:nrow(train), size = 10000), ]
    temp.data <- sample(
      c(TRUE, FALSE),
      size = nrow(train.subset),
      replace = TRUE,
      prob = c(0.8, 0.2)
    )
    temp.model <- randomForest(
      as.factor(response) ~ .,
      data = train.subset[temp.data,],
      mtry = m,
      ntree = 250  # For a little speed boost
    )
    temp.table <-
      assess.prediction(
        actual = train.subset[!temp.data,]$response,
        predicted = predict(temp.model, newdata = train.subset[!temp.data,]),
        print.vals = FALSE
      )
    rf.acc <-  rbind(rf.acc,
                     data.frame(
                       mtry = m,
                       accuracy = sum(diag(temp.table)) / sum(temp.table)
                     ))
  }
}
```

```{r RF plots}
ggplot(data = rf.acc,
       aes(
         x = as.factor(mtry),
         y = accuracy,
         color = as.factor(mtry),
         fill = as.factor(mtry)
       )) +
  geom_violin(trim = FALSE) +
  geom_boxplot(color = "black",
               fill = "white",
               width = 0.25)
```

```{r Final RF model, cache=TRUE}
# Build model based on above output trying 4 and 6
rf.full.4 <-
  randomForest(as.factor(response) ~ ., data = train, mtry = 4, ntree = 1000)
assess.prediction(actual = train$response,
                  predicted = predict(rf.full.4))

rf.full.5 <-
  randomForest(as.factor(response) ~ ., data = train, mtry = 5, ntree = 1000)
assess.prediction(actual = train$response,
                  predicted = predict(rf.full.5))

rf.full.6 <-
  randomForest(as.factor(response) ~ ., data = train, mtry = 6, ntree = 1000)
assess.prediction(actual = train$response,
                  predicted = predict(rf.full.6))

rf.full <- rf.full.5
```

Random forest slightly improves on logistic regression and LDA, with a training accuracy of $\approx90\%$ versus the previous best of $\approx89\%$ (for what that's worth). The optimal number for `mtry` appears to be $5$, although $4$ (the default value -- `floor(sqrt(17)`) and $6$ work well, too. All have about the same accuracy/sensitivity/specificity, with minor variations depending on the model being built.

The final model also uses `ntree = 1000` to build extra trees. It doesn't give much of an improvement over the default 500, but even a little boost could help!

# Problem 5: SVM (20 points)

_Develop SVM model of categorical outcome `response` deciding on the choice of kernel, cost, etc. that appear to yield better performance.  Test model performance on multiple splits of data into training and test subsets, summarize model performance in terms of accuracy/error/sensitivity/specificity and compare to the performance of the rest of the models developed above (logistic regression, LDA, random forest)._

```{r SVM, cache=TRUE}
svm.acc <- data.frame(cost = numeric(),
                      gamma = numeric(),
                      accuracy = numeric())
for (i in 1:50) {
  # Use a smaller subset (~20%) of data so it doesn't take days to run!
  train.subset <- train[sample(1:nrow(train), size = 6000), ]
  temp.data <- sample(
    c(TRUE, FALSE),
    size = nrow(train.subset),
    replace = TRUE,
    prob = c(0.8, 0.2)
  )
  res <-
    tune(
      svm,
      as.factor(response) ~ .,
      data = train.subset[temp.data,],
      kernel = "radial",
      ranges = list(cost = 10 ^ (-1:3),
                    gamma = 10 ^ (-4:1))
    )
  p <- assess.prediction(
    train.subset[!temp.data,]$response,
    predict(res$best.model, newdata = train.subset[!temp.data,]),
    print.vals = FALSE
  )
  svm.acc <- rbind(
    svm.acc,
    data.frame(
      cost = res$best.parameters$cost,
      gamma = res$best.parameters$gamma,
      accuracy = sum(diag(p)) / sum(p)
    )
  )
}
```

```{r SVM plot}
temp <- data.frame(
  measure = c(rep("accuracy", nrow(svm.acc)),
              rep("cost", nrow(svm.acc)),
              rep("gamma", nrow(svm.acc))),
  value = c(svm.acc$accuracy, svm.acc$cost, svm.acc$gamma)
)
ggplot(data = temp, aes(x = "parameter", y = value, fill = measure)) +
  facet_wrap(temp$measure, scales = "free") +
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75)) +
  geom_jitter(height = 0)
```

```{r SVM full model, cache=TRUE}
# Build model based on results above
svm.full <- svm(
  as.factor(response) ~ .,
  data = train,
  kernel = "radial",
  cost = 100,
  gamma = 0.01
)
# Check out performance on training data set
assess.prediction(actual = train$response,
                  predicted = predict(svm.full))
```

For SVM with a radial kernel, the best model appears to be one with a cost of 100 and gamma of 0.01. With more time, it's very likely that these values could be further refined, but current performance is in line with the other models ($0.904$ accuracy).

# Problem 6: predictions for test dataset  (10 points)

```{r Load and transform test data}
# Load data
test.all <- read.csv("final-data-test.csv")
anyNA(test.all)
summary(test.all)

# Remove ID
test.id <- test.all$id
test <- subset(test.all, select = -id)

# Transform variables as above
test <- cbind(
  exp.dtj = exp(test$dtj),
  log.qh = log(test$qh),
  sqrt.is = sqrt(test$is),
  subset(test, select = -c(dtj, qh, is))
)
```

## Problem 6a: compare logistic regression, LDA, random forest and SVM model performance (3 points)

_Compare performance of the models developed above (logistic regression, LDA, random forest, SVM) in terms of their accuracy, error and sensitivity/specificity.  Comment on differences and similarities between them._

```{r Compare preditctions for training}
# Data frame of training predictions
preds.train <- data.frame(
  id = train.id,
  logistic = predict(logi, newdata = train) > 0.5,
  lda = as.logical(predict(lda.full, newdata = train)$class),
  rf = as.logical(predict(rf.full, newdata = train)),
  svm = as.logical(predict(svm.full, newdata = train)),
  actual = train$response
)

# What percentage of predictions agree ...
agreement <- 
  preds.train$logistic + 
  preds.train$lda + 
  preds.train$rf + 
  preds.train$svm
# 4 out of 4 models?
sum(agreement == 4 | agreement == 0) / length(agreement)
# 3 out of 4 models?
sum(agreement != 2) / length(agreement)

# For consensus, what shoud 2 out of 4 be called as?
# "N"
sum((agreement > 2) == preds.train$actual) / nrow(train)  
# "Y"
sum((agreement >= 2) == preds.train$actual) / nrow(train)

# Check results for >= 2
assess.prediction(actual = preds.train$actual,
                  predicted = agreement >= 2)

# Check results for ANY model calling "Y"
assess.prediction(actual = preds.train$actual,
                  predicted = agreement >= 1)
```

Logistic regression (min test accuracy $0.86$, mean $0.87$, max $0.88$ with or without interaction terms) and LDA (min test accuracy $0.87$, mean $0.88$, max $0.89$) both peform similarly, with perhaps a slight edge to LDA. Random forest is another slight improvement at $0.900$ accuracy, and SVM gives about the same ($0.904$).

Using a consensus model (at least 2 out of 4 models call "Y"), the result is an accuracy of $0.913$, which is better than any one model. Somewhat surprisingly, calling "Y" when _any_ of the 4 models predicts "Y" gives the best accuracy -- $0.963$. Given that, this may be the best criteria to use in predictions for the test data.

## Problem 6b: make predictions for the **test** dataset (3 points)

_Decide on the model that performs the best and use it to make predictions for the **test** dataset.  This is the dataset that is provided separately from training data without the outcome `response` that we are modeling here.  Upload resulting predictions in comma-separated values (CSV) format into the Canvas website.  Please check sample files with test dataset predictions for the expected format of the *.csv file with predictions: your submission must be in precisely the same format -- two and only two columns, first column - ids of the test observations ("id" column in test dataset), second - predictions as Y/N calls (not 0/1, 1/2, true/false, etc.).  The name of the second column of predictions is what will be used in leaderboard as its name._

```{r Build predictions for test}
preds <- data.frame(
  id = test.id,
  logistic = predict(logi, newdata = test) > 0.5,
  lda = as.logical(predict(lda.full, newdata = test)$class),
  rf = as.logical(predict(rf.full, newdata = test)),
  svm = as.logical(predict(svm.full, newdata = test))
)
```

## Problem 6c: get better than coin flip by 10% (4 points)

_This is not really a problem *per se* but rather a criterion that we will go by when assessing quality of your predictions for the test dataset.  You get these four points if your predictions for **test** dataset are better than those obtained from a fair coin flip (already shown in leaderboard and as examples of the file format for predictions upload) by at least 10% on **all** four metrics shown in the leaderboard (accuracy, sensitivity, specificity and precision).  But then predictions by the coin flip should not be very difficult to improve upon._  

```{r Predictions!}
# Make final predictions based on consensus rather than any one model
consensus <-
  ifelse(preds$logistic + preds$lda + preds$rf + preds$svm >= 2, "Y", "N")
# Check out overall proportion -- should be similar to training (hopefully)
sum(consensus == "Y") / length(consensus)

# Above only gives 21.6% "Y," not 25% as expected
# Use any model calls "Y" as final answer
any.yes <-
  ifelse(preds$logistic |
           preds$lda | preds$rf | preds$svm, "Y", "N")
# Check out overall proportion -- should be similar to training (hopefully)
sum(any.yes == "Y") / length(any.yes)
# 23.7% more in line with expectations

# Write out predictions
write.csv(
  data.frame(id = preds$id, jrs_2019_12_16 = any.yes),
  file = "JRS_final_predictions.csv",
  row.names = FALSE
)
```

---

**NOTE: Stuff below here isn't functioning right now, but I'm leaving it in anyway.**

# Extra 5 points: KNN model

Develop KNN classifiers for various values of $K$ and compare their performance to that from the rest of the models evaluated herein.  The challenges associated with this task include: a) handling the increase in computational demands of KNN models with the increase in the size of the data, and b) deciding on the choice of the distance that is suitable for a dataset with categorical attributes. 

```{r KNN, eval=FALSE}
kvals <- c(1, 2, 3,	5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610)

knn.acc <- data.frame(k = numeric(),
                      accuracy = numeric())
for (i in 1:1) {
  train.subset <- train.subset <- train[sample(1:nrow(train), size = 3000),]
  temp.data <-
    sample(c(TRUE, FALSE), size = nrow(train.subset), replace = TRUE)
  x <- subset(train.subset[temp.data,], select = -response)
  y <- train.subset[temp.data,]$response
  # Use 5-fold cross-validation for model
  res <- tune.knn(x,
                  y,
                  k = kvals,
                  tunecontrol = tune.control(sampling = "cross", cross = 5))
  
  p <- assess.prediction(
    train.subset[!train, ]$response,
    knn(
      train = x,
      test = subset(train.subset[!temp.data,], select = -response),
      cl = y,
      k = res$best.parameters$k
    ),
    print.vals = FALSE
  )
  knn.acc <- rbind(knn.acc,
                   data.frame(
                     k = res$best.parameters$k,
                     accuracy = sum(diag(p)) / sum(p)
                   ))
}

temp <- data.frame(measure = c(rep("accuracy", nrow(knn.acc)),
                               rep("k", nrow(knn.acc))),
                   value = c(knn.acc$accuracy, knn.acc$k))
ggplot(data = temp, aes(x = "parameter", y = value, fill = measure)) +
  facet_wrap(temp$measure, scales = "free") +
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75)) +
  geom_jitter(height = 0)
```


# Extra 10 points: neural network model

Experiment with fitting neural network models of categorical outcome `response` for this data and evaluate their performance on different splits of the data into training and test. Compare model performance to that for the rest of classifiers developed above.

```{r NN formula, eval=FALSE}
form <-  as.formula(paste("response ~", 
                          paste(names(train)[2:18], collapse = " + ")))
```


```{r Neural Net with 1 layer, cache=TRUE, eval=FALSE}
res.1 <- data.frame(nodes = numeric(),
                    error = numeric())

for (n.nodes in c(1:10 * 3)) {
  nn.1 <- neuralnet(
    formula = form,
    data = train,
    hidden = n.nodes,
    err.fct = "sse",
    linear.output = TRUE,
    threshold = 0.5
  )
  res.1 <-
    rbind(res.1,
          data.frame(nodes = n.nodes,
                     error = sum(
                       nn.1$err.fct(nn.1$net.result[[1]], nn.1$response)
                     )))
}

```

```{r Neural Net with 2 layers, cache=TRUE, eval=FALSE}
res.2 <- data.frame(layer1 = numeric(),
                    layer2 = numeric(),
                    error = numeric())
for (n1 in 2 ^ (2:5)) {
  for (n2 in 2 ^ (2:5)) {
    nn.2 <- neuralnet(
      formula = form,
      data = train,
      hidden = c(n1, n2),
      err.fct = "sse",
      linear.output = TRUE,
      threshold = 0.5,
      stepmax = 1e6
    )
    res.2 <-
      rbind(res.2,
            data.frame(
              layer1 = n1,
              layer2 = n2,
              error = sum(nn.1$err.fct(nn.2$net.result[[1]], nn.2$response))
            ))
  }
}
```

```{r NN Info, eval=FALSE}
# NN results tables
res.1
res.2

# Plots
ggplot(data = res.1, aes(x = nodes, y = error)) + 
  geom_point(size = 3) + 
  geom_line() +
  scale_x_continuous(breaks = seq(2, 32, by = 2)) +
  scale_y_log10() +
  labs(title = "Error vs Number of Nodes in 1 layer Neural Net",
       x = "Number of Nodes",
       y = "Error")

# Adding 1 to error in case there's a 0 error result -- log scale for Y axis fails
ggplot(data = res.2, aes(x = layer1, y = error + 1, color = as.factor(layer2))) + 
  geom_point(size = 3) + 
  geom_line() +
  scale_x_continuous(trans = "log2") +
  scale_y_log10() +
  labs(title = "Error vs Number of Nodes in 2 layer Neural Net",
       x = "Layer 1 Nodes",
       y = "Error", 
       color = "Layer 2 Nodes")
```

```{r NN final model, eval=FALSE}
# Use lowest error from above for full model
nn.full <- neuralnet(
  formula = form,
  data = train,
  hidden = c(8, 8),
  err.fct = "sse",
  linear.output = TRUE,
  threshold = 0.5,
  stepmax = 1e6
)
                     
```


# An afterword on the computational demands of the final exam

Because during previous offerings of this course there were always several posts on piazza regarding how long it takes to fit various classifiers to the final exam dataset we have added this note here.

First of all, we most definitely do *not* expect you to *have* to buy capacity from AWS to complete this assignment. You certainly can if you want to, but this course is not about that and this dataset is really not *that* big to require it. Something reasonable/useful can be accomplished for this data with middle of the road hardware. For instance, knitting of the entire official solution for the final exam on 8Gb RAM machine with two i5-7200u cores takes about an hour using single-threaded R/Rstudio and this includes both extra points problems as well as various assessments of the performance of different models as function of data size and so on.

Second, your solution should not take hours and hours to compile. If it does, it could be that it is attempting to do too much, or something is implemented inefficiently, or just plain incorrectly - it is impossible for us to comment on this until we see the code when we grade it. In general, it is often very prudent to "start small" -- fit your model on a random subset of data small enough for the model fitting call to return immediately, check how model performance (both in terms of error and time it takes to compute) scales with the size of the data you are training it on (as you increase it in size, say, two-fold several times), for tuning start with very coarse grid of parameter values and given those results decide what it right for you, etc.

Lastly, making the decision about what is right for the problem at hand, how much is enough, etc. is inherent in this line of work. If you choose to conduct model tuning on a subset of the data - especially if you have some assessment of how the choice of tuning parameter and test error is affected by the size of training dataset - it could be a very wise choice.  If it is more efficient for you to knit each problem separately, by all means feel free to do that - just remember to submit each .Rmd and HTML file that comprises your entire solution. On that note, if you end up using any of the unorthodox setups for your calculations (e.g. AWS, parallel processing, multiple machines, etc. - none of which are essential for solving it correctly) please be sure that when we grade we have every relevant piece of code available - we won't be able to grade your work if we are not clear about how the results were obtained.

In the end, the final exam asks you to assess performance of several classification technologies on a new dataset, decide on which classifier is the best and use it to make predictions for the test data. It is very much up to you how exactly you want to go about it.  There could be many versions of correct and informative solution for that (as there could be just as many if not more that are completely wrong).

As always, best of luck - we are practically done here!

```{r Session info}
sessionInfo()
```